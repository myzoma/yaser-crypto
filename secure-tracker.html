<!DOCTYPE html>
<html dir="rtl" lang="ar">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ù…ØªØªØ¨Ø¹ Ø§Ù„ØªÙˆØµÙŠØ§Øª</title>
   <style>
    body { 
        font-family: Arial, sans-serif; 
        margin: 20px; 
        background: #0d1117; 
        color: #e6edf3;
    }
    
    .container { 
        max-width: 1200px; 
        margin: 0 auto; 
        background: #161b22; 
        padding: 20px; 
        border-radius: 10px; 
        border: 1px solid #30363d;
    }
    
    .controls { 
        margin-bottom: 20px; 
    }
    
    button { 
        padding: 10px 20px; 
        margin: 5px; 
        border: none; 
        border-radius: 5px; 
        cursor: pointer; 
        transition: all 0.3s ease;
    }
    
    .btn-primary { 
        background: #238be6; 
        color: white; 
    }
    .btn-primary:hover { 
        background: #1f7acc; 
    }
    
    .btn-success { 
        background: #2ea043; 
        color: white; 
    }
    .btn-success:hover { 
        background: #238636; 
    }
    
    .btn-info { 
        background: #1f6feb; 
        color: white; 
    }
    .btn-info:hover { 
        background: #1158c7; 
    }
    
    table { 
        width: 100%; 
        border-collapse: collapse; 
        margin-top: 20px; 
        background: #0d1117;
    }
    
    th, td { 
        padding: 10px; 
        border: 1px solid #30363d; 
        text-align: center; 
        color: #e6edf3;
    }
    
    th { 
        background: #21262d; 
        color: #f0f6fc;
        font-weight: 600;
    }
    
    .profit-positive { 
        color: #3fb950; 
        font-weight: bold; 
    }
    
    .profit-negative { 
        color: #f85149; 
        font-weight: bold; 
    }
    
    .status-completed { 
        background: #0d4429; 
        color: #3fb950;
    }
    
    .status-pending { 
        background: #332b00; 
        color: #d29922;
    }
    
    .stats { 
        display: grid; 
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); 
        gap: 15px; 
        margin-bottom: 20px; 
    }
    
    .stat-card { 
        background: #21262d; 
        padding: 15px; 
        border-radius: 8px; 
        text-align: center; 
        border: 1px solid #30363d;
        color: #e6edf3;
    }
    
    .stat-card h3 {
        color: #f0f6fc;
        margin-top: 0;
    }
</style>

</head>
<body>
    <div class="container">
        <h1>ğŸ“Š Ù…ØªØªØ¨Ø¹ Ø§Ù„ØªÙˆØµÙŠØ§Øª</h1>
        
        <div class="controls">
            <button class="btn-primary" onclick="captureRecommendations()">ğŸ“Š Ø§Ù„ØªÙ‚Ø§Ø· Ø§Ù„ØªÙˆØµÙŠØ§Øª Ù…Ù† OKX</button>
            <button class="btn-success" onclick="updatePrices()">ğŸ”„ ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø£Ø³Ø¹Ø§Ø±</button>
            <button class="btn-info" onclick="generateReport()">ğŸ“ˆ ØªÙ‚Ø±ÙŠØ± Ù…ÙØµÙ„</button>
            <button class="btn-danger" onclick="clearData()" style="background: #dc3545; color: white;">ğŸ—‘ï¸ Ù…Ø³Ø­ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª</button>
        </div>
        
        <div class="stats" id="stats"></div>
        <div id="recommendations"></div>
    </div>

    <script>
        let recommendations = JSON.parse(localStorage.getItem('recommendations') || '[]');

        async function captureRecommendations() {
            try {
                // Ø¬Ù„Ø¨ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ù…Ø¨Ø§Ø´Ø±Ø© Ù…Ù† OKX
                const response = await fetch('https://www.okx.com/api/v5/market/tickers?instType=SPOT');
                const data = await response.json();
                
                if (!data.data) {
                    throw new Error('ÙØ´Ù„ ÙÙŠ Ø¬Ù„Ø¨ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª');
                }

                // ÙÙ„ØªØ±Ø© Ø£ÙØ¶Ù„ Ø§Ù„Ø¹Ù…Ù„Ø§Øª
                const topCoins = data.data
                    .filter(ticker => ticker.instId.endsWith('-USDT'))
                    .map(ticker => {
                        const currentPrice = parseFloat(ticker.last);
                        const openPrice = parseFloat(ticker.open24h);
                        const change24h = ((currentPrice - openPrice) / openPrice) * 100;
                        
                        return {
                            symbol: ticker.instId.replace('-USDT', ''),
                            price: currentPrice,
                            change24h: change24h,
                            volume: parseFloat(ticker.vol24h)
                        };
                    })
                    .filter(coin => coin.change24h > 2 && coin.change24h < 20) // ÙÙ„ØªØ±Ø© Ø§Ù„Ø¹Ù…Ù„Ø§Øª Ø§Ù„ØµØ§Ø¹Ø¯Ø©
                    .sort((a, b) => b.change24h - a.change24h)
                    .slice(0, 15); // Ø£ÙØ¶Ù„ 15 Ø¹Ù…Ù„Ø©

                if (topCoins.length === 0) {
                    alert('âŒ Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ø¹Ù…Ù„Ø§Øª Ù…Ù†Ø§Ø³Ø¨Ø©');
                    return;
                }

                // Ø­ÙØ¸ Ø§Ù„ØªÙˆØµÙŠØ§Øª
                const timestamp = new Date().toISOString();
                topCoins.forEach((coin, index) => {
                    const rec = {
                        id: Date.now() + Math.random(),
                        symbol: coin.symbol,
                        entryPrice: coin.price,
                        currentPrice: coin.price,
                        target1: coin.price * 1.05, // Ù‡Ø¯Ù 5%
                        target2: coin.price * 1.10, // Ù‡Ø¯Ù 10%
                        target3: coin.price * 1.15, // Ù‡Ø¯Ù 15%
                        stopLoss: coin.price * 0.95, // ÙˆÙ‚Ù Ø®Ø³Ø§Ø±Ø© 5%
                        timestamp: timestamp,
                        status: 'pending',
                        profit: 0,
                        rank: index + 1,
                        change24h: coin.change24h
                    };
                    recommendations.push(rec);
                });

                localStorage.setItem('recommendations', JSON.stringify(recommendations));
                renderRecommendations();
                updateStats();
                alert(`âœ… ØªÙ… Ø§Ù„ØªÙ‚Ø§Ø· ${topCoins.length} ØªÙˆØµÙŠØ© Ø¬Ø¯ÙŠØ¯Ø©`);

            } catch (error) {
                console.error('Ø®Ø·Ø£ ÙÙŠ Ø§Ù„ØªÙ‚Ø§Ø· Ø§Ù„ØªÙˆØµÙŠØ§Øª:', error);
                alert('âŒ Ø®Ø·Ø£ ÙÙŠ Ø§Ù„ØªÙ‚Ø§Ø· Ø§Ù„ØªÙˆØµÙŠØ§Øª: ' + error.message);
            }
        }

        async function updatePrices() {
            if (recommendations.length === 0) {
                alert('âŒ Ù„Ø§ ØªÙˆØ¬Ø¯ ØªÙˆØµÙŠØ§Øª Ù„Ù„ØªØ­Ø¯ÙŠØ«');
                return;
            }

            try {
                // Ø¬Ù„Ø¨ Ø§Ù„Ø£Ø³Ø¹Ø§Ø± Ø§Ù„Ø­Ø§Ù„ÙŠØ©
                const response = await fetch('https://www.okx.com/api/v5/market/tickers?instType=SPOT');
                const data = await response.json();
                
                const priceMap = {};
                data.data.forEach(ticker => {
                    if (ticker.instId.endsWith('-USDT')) {
                        const symbol = ticker.instId.replace('-USDT', '');
                        priceMap[symbol] = parseFloat(ticker.last);
                    }
                });

                // ØªØ­Ø¯ÙŠØ« Ø£Ø³Ø¹Ø§Ø± Ø§Ù„ØªÙˆØµÙŠØ§Øª
                recommendations.forEach(rec => {
                    if (rec.status === 'pending' && priceMap[rec.symbol]) {
                        rec.currentPrice = priceMap[rec.symbol];
                        rec.profit = ((rec.currentPrice - rec.entryPrice) / rec.entryPrice) * 100;

                        // ÙØ­Øµ Ø§Ù„Ø£Ù‡Ø¯Ø§Ù
                        if (rec.currentPrice >= rec.target1) {
                            rec.status = 'completed';
                            rec.completedAt = new Date().toISOString();
                        } else if (rec.currentPrice <= rec.stopLoss) {
                            rec.status = 'stopped';
                            rec.stoppedAt = new Date().toISOString();
                        }
                    }
                });

                localStorage.setItem('recommendations', JSON.stringify(recommendations));
                renderRecommendations();
                updateStats();
                alert('âœ… ØªÙ… ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø£Ø³Ø¹Ø§Ø±');

            } catch (error) {
                console.error('Ø®Ø·Ø£ ÙÙŠ ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø£Ø³Ø¹Ø§Ø±:', error);
                alert('âŒ Ø®Ø·Ø£ ÙÙŠ ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø£Ø³Ø¹Ø§Ø±: ' + error.message);
            }
        }

        function renderRecommendations() {
            const container = document.getElementById('recommendations');
            
            if (recommendations.length === 0) {
                container.innerHTML = '<p>Ù„Ø§ ØªÙˆØ¬Ø¯ ØªÙˆØµÙŠØ§Øª. Ø§Ø¶ØºØ· "Ø§Ù„ØªÙ‚Ø§Ø· Ø§Ù„ØªÙˆØµÙŠØ§Øª Ù…Ù† OKX" Ù„Ù„Ø¨Ø¯Ø¡.</p>';
                return;
            }

            const html = `
                <table>
                    <thead>
                        <tr>
                            <th>Ø§Ù„ØªØ±ØªÙŠØ¨</th>
                            <th>Ø§Ù„Ø¹Ù…Ù„Ø©</th>
                            <th>Ø³Ø¹Ø± Ø§Ù„Ø¯Ø®ÙˆÙ„</th>
                            <th>Ø§Ù„Ø³Ø¹Ø± Ø§Ù„Ø­Ø§Ù„ÙŠ</th>
                            <th>Ø§Ù„Ù‡Ø¯Ù Ø§Ù„Ø£ÙˆÙ„</th>
                            <th>Ø§Ù„Ø±Ø¨Ø­ %</th>
                            <th>Ø§Ù„Ø­Ø§Ù„Ø©</th>
                            <th>Ø§Ù„ØªØ§Ø±ÙŠØ®</th>
                        </tr>
                    </thead>
                    <tbody>
                        ${recommendations.map(rec => `
                            <tr class="status-${rec.status}">
                                <td>${rec.rank}</td>
                                <td><strong>${rec.symbol}</strong></td>
                                <td>${rec.entryPrice.toFixed(6)}</td>
                                <td>${rec.currentPrice.toFixed(6)}</td>
                                <td>${rec.target1.toFixed(6)}</td>
                                <td class="${rec.profit >= 0 ? 'profit-positive' : 'profit-negative'}">
                                    ${rec.profit.toFixed(2)}%
                                </td>
                                <td>${getStatusText(rec.status)}</td>
                                <td>${new Date(rec.timestamp).toLocaleDateString('ar')}</td>
                            </tr>
                        `).join('')}
                    </tbody>
                </table>
            `;
            
            container.innerHTML = html;
        }

        function updateStats() {
            const total = recommendations.length;
            const completed = recommendations.filter(r => r.status === 'completed').length;
            const pending = recommendations.filter(r => r.status === 'pending').length;
            const stopped = recommendations.filter(r => r.status === 'stopped').length;
            const successRate = total > 0 ? ((completed / total) * 100).toFixed(1) : 0;
            const avgProfit = total > 0 ? (recommendations.reduce((sum, r) => sum + r.profit, 0) / total).toFixed(2) : 0;

            document.getElementById('stats').innerHTML = `
                <div class="stat-card">
                    <h3>ğŸ“Š Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø§Ù„ØªÙˆØµÙŠØ§Øª</h3>
                    <p style="font-size: 24px; font-weight: bold;">${total}</p>
                </div>
                <div class="stat-card">
                    <h3>âœ… Ù†Ø¬Ø­</h3>
                    <p style="font-size: 24px; font-weight: bold; color: #28a745;">${completed}</p>
                </div>
                <div class="stat-card">
                    <h3>â³ Ù‚ÙŠØ¯ Ø§Ù„Ø§Ù†ØªØ¸Ø§Ø±</h3>
                    <p style="font-size: 24px; font-weight: bold; color: #ffc107;">${pending}</p>
                </div>
                <div class="stat-card">
                    <h3>ğŸ“ˆ Ù…Ø¹Ø¯Ù„ Ø§Ù„Ù†Ø¬Ø§Ø­</h3>
                    <p style="font-size: 24px; font-weight: bold; color: #17a2b8;">${successRate}%</p>
                </div>
                <div class="stat-card">
                    <h3>ğŸ’° Ù…ØªÙˆØ³Ø· Ø§Ù„Ø±Ø¨Ø­</h3>
                    <p style="font-size: 24px; font-weight: bold; color: ${avgProfit >= 0 ? '#28a745' : '#dc3545'};">${avgProfit}%</p>
                </div>
            `;
        }

        function getStatusText(status) {
            switch(status) {
                case 'pending': return 'â³ Ù‚ÙŠØ¯ Ø§Ù„Ø§Ù†ØªØ¸Ø§Ø±';
                case 'completed': return 'âœ… ØªÙ… ØªØ­Ù‚ÙŠÙ‚ Ø§Ù„Ù‡Ø¯Ù';
                case 'stopped': return 'âŒ ÙˆÙ‚Ù Ø®Ø³Ø§Ø±Ø©';
                default: return status;
            }
        }

        function generateReport() {
            if (recommendations.length === 0) {
                alert('âŒ Ù„Ø§ ØªÙˆØ¬Ø¯ Ø¨ÙŠØ§Ù†Ø§Øª Ù„Ù„ØªÙ‚Ø±ÙŠØ±');
                return;
            }

            const report = `
ğŸ“Š ØªÙ‚Ø±ÙŠØ± Ø§Ù„ØªÙˆØµÙŠØ§Øª
==================
Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø§Ù„ØªÙˆØµÙŠØ§Øª: ${recommendations.length}
Ù†Ø¬Ø­: ${recommendations.filter(r => r.status === 'completed').length}
Ù‚ÙŠØ¯ Ø§Ù„Ø§Ù†ØªØ¸Ø§Ø±: ${recommendations.filter(r => r.status === 'pending').length}
Ù…Ø¹Ø¯Ù„ Ø§Ù„Ù†Ø¬Ø§Ø­: ${recommendations.length > 0 ? ((recommendations.filter(r => r.status === 'completed').length / recommendations.length) * 100).toFixed(1) : 0}%

Ø£ÙØ¶Ù„ Ø§Ù„Ø¹Ù…Ù„Ø§Øª:
${recommendations
    .filter(r => r.profit > 0)
    .sort((a, b) => b.profit - a.profit)
    .slice(0, 5)
    .map(r => `${r.symbol}: +${r.profit.toFixed(2)}%`)
    .join('\n')}
            `;
            
            alert(report);
        }

        function clearData() {
            if (confirm('Ù‡Ù„ Ø£Ù†Øª Ù…ØªØ£ÙƒØ¯ Ù…Ù† Ù…Ø³Ø­ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§ØªØŸ')) {
                recommendations = [];
                localStorage.removeItem('recommendations');
                renderRecommendations();
                updateStats();
                alert('âœ… ØªÙ… Ù…Ø³Ø­ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª');
            }
        }

        // ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø¹Ù†Ø¯ ÙØªØ­ Ø§Ù„ØµÙØ­Ø©
        document.addEventListener('DOMContentLoaded', function() {
            renderRecommendations();
            updateStats();
        });
    </script>
</body>
</html>
